proxy = reactiveBundle(bundle, opts = {})
* Returns an object or array proxy (depending on the type of the supplied
* bundle) of reactive values for the members of the original bundle.
* Options:
*   shallow - disable automatic proxying of nested bundles

Assigning a non-reactive value to a member of the bundle reactively tracks
that value. If you assign a different value to that member, any reactive
values defined using the bundle member will automatically update.

In the spreadsheet analogy, assigning a non-reactive value to a bundle member
is like writing a value to a cell, and any reactive references to the bundle
member access it by formula.

If you assign a reactive value to a member of the bundle, it doesn't just
use the current value of the reactive -- it creates a "tracking chain".
In other words, if the reactive value on the right-hand side of the
assignment changes, the value of the bundle member it was assigned to also
updates.

Using the spreadsheet analogy again, assigning a reactive value to a bundle
member is like setting it to a formula accessing the assigned value, rather
than the assigned value itself.

proxy ("instance" properties and methods)
-----------------------------------------

_ - A bundle of member reactives

__ - The bundle's master reactive
* This reactive ripples a change when a member is added or removed
* from the bundle (in contrast to member-value changes), e.g.:
* reactive({ eager: true, def: () => {
*   proxy.__; console.log('Bundle keys changed'); }});

_bundle() - Returns a snapshot of the underlying, non-reactive bundle

join(sep = ',') - In array mode, returns _bundle().join(sep)

length = value - Sets the array length in array mode
* The value may be either a plain number or a reactive number.

length - Returns the *reactive* array length in array mode
* This value reacts to assignments, push/pop, shift/unshift, splice, etc.

member - Returns the member's (usually) reactive value or bundle proxy

member = value - Sets a bundle member to a value
* A member reactive ripples when existing reactive values change.
* The master reactive ripples when adding or removing reactive-valued keys.
* Function values and symbol-keyed members are stored as-is.
* External scalar reactive values are tracked via def.
* Arrays and objects are automatically recursively bundled unless the
* shallow option is set.

member.rv - The member's current value for reactive.type values

$reactive - The reactive type (reactiveBundle.type)

Standard array operations on array bundles happen in a reactive batch, and
array-valued functions return an array bundle (proxy).

reactiveBundle ("class" properties and methods)
-----------------------------------------------

type - 2 (reactive bundle)

update(dstProxy, srcBundle) - Update the existing reactive bundle (dstProxy)
* in-place with (keys and) values from the raw (non-reactive) srcBundle.
* Array bundles are quasi-set-like: dstProxy values not in srcBundle are
* spliced out and unique values only in srcBundle are pushed onto the end.

EXAMPLES

r1 = reactive({ v: 1 });
// r2 tracks r1
r2 = reactive({ def: r1 });	// or def: r1.getter or def: () => r1.rv
r2.rv;		// 1
r3 = reactiveBundle([]);
// Accessing or tracking potentially undefined members takes a little more
// care as shown in r4, which tracks r3[0]...
r4 = reactive({ def: () => r3[0]?.rv });
r3[1] = r1;	// r3[0] is currently empty/undefined
r4.rv;		// undefined
r3.shift();	// r3[0] added from r3[1]; r3[1] removed
r4.rv;		// 1
