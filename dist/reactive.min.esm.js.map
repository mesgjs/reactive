{"version":3,"file":"reactive.min.esm.js","sources":["../src/reactive.esm.js"],"sourcesContent":["/*\n * reactive\n * A reactive value library supporting memoization and per-value\n * selection of lazy or eager, chain-less dependency evaluation.\n *\n * Copyright 2023-2025 by Kappa Computer Solutions, LLC and Brian Katzung\n * Author: Brian Katzung <briank@kappacs.com>\n */\n\n// Return a new reactive value object\nfunction reactive (opts = {}) {\n\tconst r = Object.setPrototypeOf({\n\t\t_v: opts.v,\t\t\t\t\t\t// Current value\n\t\t_cmp: opts.compare,\t\t\t\t// Comparison function/value\n\t\t_rdy: true,\t\t\t\t\t\t// Ready?\n\t\t_eager: opts.eager,\t\t\t\t// Eager function eval\n\t\t_pros: new Set(),\t\t\t\t// Providers\n\t\t_cons: new Set(),\t\t\t\t// Consumers\n\t\t// _busy: true/undefined,\t\t// Currently evaluating definition\n\t\t// _def: undefined,\t\t\t\t// Reactive definition/memo/effect\n\t\t// _g: undefined,\t\t\t\t// Getter function\n\t\t// _rov: undefined,\t\t\t\t// Read-only view\n\t\t// _sched: undefined,\t\t\t// Eval queue if scheduled\n\t\t// _s: undefined,\t\t\t\t// Setter function\n\n\t}, reactive._prototype);\n\n\tif (opts.compare === undefined) r._cmp = r._defcmp;\n\tif (opts.def) r.def = opts.def;\n\n\treturn r;\n}\n\n(r => {\n\t// Read-only-view prototype for reactive values\n\tr._roPrototype = {\n\t\tget $reactive () { return r.type; },\n\t\tget readonly () { return true; },\n\t\tget rv () { return this.getter(); },\n\t\ttoString () { return this.getter().toString(); },\n\t\tvalueOf () { return this.getter(); },\n\t};\n\t// Full-access prototype for reactive values\n\tr._prototype = Object.setPrototypeOf({\n\t\t/* PUBLIC ATTRIBUTES */\n\t\tget accessors () { return [this.getter, this.setter]; },\n\t\tget compare () { return this._cmp; },\n\t\tget def () { return this._def; },\n\t\tset def (d) {\t\t\t\t\t// Set/change/clear definition\n\t\t\tif (d === undefined) {\t\t// Clear\n\t\t\t\tif (this._def) {\n\t\t\t\t\tthis.provider(null);\n\t\t\t\t\tdelete this._def;\n\t\t\t\t\tthis._setNotify(undefined);\n\t\t\t\t}\n\t\t\t} else if (typeof d === 'function') {\n\t\t\t\t// Set/change\n\t\t\t\tthis.provider(null);\n\t\t\t\tthis._def = d;\n\t\t\t\tdelete this._error;\n\t\t\t\tthis._rdy = false;\n\t\t\t\tthis._schedule();\n\t\t\t} else if (d?.$reactive === r.type) {\n\t\t\t\t// Clone a reactive value using its getter function\n\t\t\t\tthis.def = d.getter;\n\t\t\t}\n\t\t},\n\t\tget eager () { return this._eager; },\n\t\tset eager (e) {\t\t\t\t\t// Change def eval eagerness\n\t\t\tthis._eager = e;\n\t\t\tthis._schedule();\n\t\t},\n\t\tget error () { return this._error; },\n\t\tget getter () {\t\t\t\t\t// Return getter function\n\t\t\treturn (this._g ||= () => this.rv);\n\t\t},\n\t\t// Return [getter, setter] pair\n\t\tget $reactive () { return r.type; },\n\t\tget readonly () { return false; },\n\t\tget readonlyView () {\t\t\t// Get read-only view\n\t\t\tif (!this._rov) {\n\t\t\t\tthis._rov = Object.freeze(Object.setPrototypeOf({\n\t\t\t\t\tget error () { return this._error; },\n\t\t\t\t\tgetter: this.getter,\n\t\t\t\t}, r._roPrototype));\n\t\t\t}\n\t\t\treturn this._rov;\n\t\t},\n\t\tget rv () {\t\t\t\t\t\t// Current value (readable)\n\t\t\tif (this._sched !== undefined) {\n\t\t\t\t// Remove from scheduled evaluation queue\n\t\t\t\tr._REQ[this._sched].delete(this);\n\t\t\t\tdelete this._sched;\n\t\t\t}\n\t\t\tif (r._consumer && !r._untrack) {\n\t\t\t\t// Producer-consumer tracking\n\t\t\t\tthis.consumer(r._consumer);\n\t\t\t\tr._consumer.provider(this);\n\t\t\t}\n\t\t\tif (!this._checkReady()) {\t// Recompute defined value?\n\t\t\t\t// Croak if trying to recursively reference our reactive\n\t\t\t\t// in order to define our value\n\t\t\t\tif (this._busy) throw new ReferenceError('Self-referential reactive definition');\n\t\t\t\t// Providers can change every iteration; start fresh\n\t\t\t\tthis.provider(null);\n\t\t\t\tconst pc = r._consumer; // Save previous consumer\n\t\t\t\tr._consumer = this;\t\t// We're the consumer now\n\t\t\t\tthis._busy = true;\t\t// For recursive def detection\n\t\t\t\t\t\t\t\t\t\t// Evaluate definition\n\t\t\t\ttry {\n\t\t\t\t\tdelete this._error;\n\t\t\t\t\tconst res = this._def(this._v);\n\t\t\t\t\tdelete this._busy;\n\t\t\t\t\tr._consumer = pc;\t// Restore previous consumer\n\t\t\t\t\tif (res?.then) {\n\t\t\t\t\t\tconsole.error('Then-able reactive result!');\n\t\t\t\t\t\tthrow new TypeError('Then-able reactive result!');\n\t\t\t\t\t}\n\t\t\t\t\tthis._setNotify(res);\n\t\t\t\t} catch (e) {\t\t\t// Try to clean up, unwind on error\n\t\t\t\t\tdelete this._busy;\n\t\t\t\t\tr._consumer = pc;\n\t\t\t\t\tthis._error = e;\n\t\t\t\t\tthis._rdy = true;\t// The error is our new result\n\t\t\t\t\tthis.ripple();\n\t\t\t\t\tif (this._eager && !this._cons.size) {\n\t\t\t\t\t\t// In space, no one can hear you scream\n\t\t\t\t\t\tqueueMicrotask(() => { throw new Error(`[Reactive] ${e.message}`, { cause: [ e, this ] }); });\n\t\t\t\t\t}\n\t\t\t\t\tthrow e;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (this._error) throw this._error;\n\t\t\treturn this._v;\n\t\t},\n\t\tget setter () {\t\t\t\t\t// Return setter function\n\t\t\treturn (this._s ||= vvf => this._set(vvf));\n\t\t},\n\t\tget wv () { return this.rv; },\t// Writable value\n\t\tset wv (v) {\n\t\t\t// Setting a static value clears any existing definition.\n\t\t\t// Unlike the setter function, a functional v is not special.\n\t\t\tif (this._def) this.def = undefined;\n\t\t\tthis._setNotify(v);\n\t\t},\n\t\t/* PUBLIC METHODS */\n\t\tconsumer (c, add = true) {\t\t// Add/remove consumer\n\t\t\tif (add) this._cons.add(c);\n\t\t\telse this._cons.delete(c);\n\t\t},\n\t\tprovider (p, add = true) {\t\t// Add/remove/remove all provider(s)\n\t\t\tif (p === null) {\n\t\t\t\t// Unsub from, and clear, all current providers\n\t\t\t\tfor (const cp of this._pros) cp.consumer(this, false);\n\t\t\t\tthis._pros.clear();\n\t\t\t}\n\t\t\telse if (add) this._pros.add(p);\n\t\t\telse this._pros.delete(p);\n\t\t},\n\t\t// Ripple ready-state changes through consumers\n\t\tripple (dis = 0) {\n\t\t\t// Distance 0: our value changed\n\t\t\t// Distance 1: an adjacent value changed\n\t\t\t// Distance >1: a more distant value changed; our recalc may or\n\t\t\t//\t may not be required depending on intermediate results\n\t\t\tconst wasReady = this._rdy;\n\t\t\tif (dis === 1) this._rdy = false;\n\t\t\tif (dis > 1 && this._rdy) this._rdy = undefined;\n\t\t\t// Ripple if local or transitioning from ready\n\t\t\tif (!dis || (wasReady && !this._rdy)) {\n\t\t\t\t++r._evalWait;\n\t\t\t\tconst nxt = dis + 1;\n\t\t\t\tfor (const con of this._cons) con.ripple(nxt);\n\t\t\t\t--r._evalWait;\n\t\t\t}\n\t\t\tthis._schedule(dis);\t\t// Call me, maybe!\n\t\t},\n\t\tset (vvf) {\t\t\t\t\t\t// Chainable set\n\t\t\t// e.g. .setEager(0).set(v0).setDef(v => f(v)).setEager(1)\n\t\t\t// Accepts a value or a mapping function (like setter(vvf)).\n\t\t\tthis._set(vvf);\n\t\t\treturn this;\n\t\t},\n\t\t// Set value; ripple-notify consumers of changes\n\t\tsetDef (d) {\t\t\t\t\t// Set def (chainable)\n\t\t\tthis.def = d;\n\t\t\treturn this;\n\t\t},\n\t\tsetEager (e) {\t\t\t\t\t// Set eager (chainable)\n\t\t\tthis.eager = e;\n\t\t\treturn this;\n\t\t},\n\t\tunready () {\t\t\t\t\t// Force unready\n\t\t\tif (this._def) this._rdy = false;\n\t\t\tthis._schedule();\n\t\t\treturn this;\n\t\t},\n\t\t/* PRIVATE METHODS */\n\t\t_checkReady () {\t\t\t\t// Determine boolean readiness\n\t\t\tif (this._rdy !== undefined) return this._rdy;\n\t\t\t/*\n\t\t\t * When the readiness is undefined, check providers for ripple\n\t\t\t * changes. If any provider has changed, we must recalculate too.\n\t\t\t */\n\t\t\tfor (const pro of this._pros) {\n\t\t\t\t// Provider changes will be rippled to us (d=1)\n\t\t\t\tpro.rv;\n\t\t\t\tif (this._rdy === false) return false;\n\t\t\t}\n\t\t\t/*\n\t\t\t * No providers rippled a change to us during (recursive)\n\t\t\t * dependency checking, so we're actually still ready!\n\t\t\t */\n\t\t\treturn (this._rdy = true);\n\t\t},\n\t\t_defcmp (a, b) { return a !== b; },// Default comparison function\n\t\t_schedule (dis = 0) {\t\t\t// Schedule for eval if needed\n\t\t\tif (!this._rdy && this._sched === undefined && (this._eager || this._cons.size)) r._queueEval(this, dis);\n\t\t\tr.run();\n\t\t},\n\t\t_set (vvf) {\t\t\t\t\t// Prototype setter\n\t\t\t// Setting a static value clears any existing definition.\n\t\t\t// Accepts a value or an old-to-new-value mapping function.\n\t\t\tif (this._def) this.def = undefined;\n\t\t\tif (typeof vvf === 'function') this._setNotify(vvf(this._v));\n\t\t\telse this._setNotify(vvf);\n\t\t\treturn this._v;\n\t\t},\n\t\t_setNotify (v) {\n\t\t\tconst chg = (typeof this._cmp === 'function') ? this._cmp(this._v, v) : this._cmp;\n\t\t\tthis._v = v;\n\t\t\tthis._rdy = true;\n\t\t\tdelete this._error;\n\t\t\tif (chg) this.ripple();\n\t\t},\n\t}, r._roPrototype);\n\n\t// Yielding recalculation queue runner\n\tasync function runner () {\n\t\tr._runner = undefined;\n\t\tif (!r._evalWait) {\n\t\t\t++r._evalWait;\n\t\t\tconst [ q0, q1, q2 ] = r._REQ;\n\t\t\tconst getFirst = (q) => q.values().next().value;\n\t\t\tconst runFirst = (q) => { try { getFirst(q).rv; } catch (_err) {/**/} };\n\t\t\tlet lastYield = performance.now();\n\t\t\tconst cede = async () => {\n\t\t\t\tif (performance.now() - lastYield >= r.sliceTime) {\n\t\t\t\t\tawait new Promise(r => setTimeout(r, 0));\n\t\t\t\t\tlastYield = performance.now();\n\t\t\t\t}\n\t\t\t};\n\t\t\t/*\n\t\t\t * NB: .rv exceptions will be rethrown to consumers; we\n\t\t\t * deliberately ignore them and process the rest of the graph.\n\t\t\t * Abort if evalWait goes up (running a batch).\n\t\t\t */\n\t\t\twhile (r._evalWait < 2) {\n\t\t\t\twhile (q0.size && r._evalWait < 2) {\n\t\t\t\t\trunFirst(q0);\n\t\t\t\t\tawait cede();\n\t\t\t\t}\n\t\t\t\tif (r._evalWait > 1) break;\n\t\t\t\telse if (q1.size) runFirst(q1);\n\t\t\t\telse if (q2.size) runFirst(q2);\n\t\t\t\telse break;\t\t\t\t// All queues empty\n\t\t\t\tawait cede();\n\t\t\t}\n\t\t\t--r._evalWait;\n\t\t\tif (r._waiting && !q0.size && !q1.size && !q2.size) {\n\t\t\t\t// Queues are now all empty; signal waiters\n\t\t\t\tconst resolve = r._waiting.resolve;\n\t\t\t\tr._waiting = undefined;\n\t\t\t\tresolve(true);\n\t\t\t}\n\t\t}\n\t}\n\n\tObject.assign(r, {\n\t\t_evalWait: 0,\t\t\t\t\t// Suspend evaluation\n\t\tsliceTime: 5,\t\t\t\t\t// Slice yield threshold (ms)\n\t\t_tasks: [],\t\t\t\t\t\t// Run-queue tasks\n\t\t_untrack: 0,\t\t\t\t\t// Suspend tracking\n\t\t// Reactive evaluation queues\n\t\t_REQ: [ new Set(), new Set(), new Set() ],\n\t\t/* PUBLIC METHODS */\n\t\tbatch (cb) {\t\t\t\t\t// Execute callback as a batch\n\t\t\t++r._evalWait;\n\t\t\tconst res = cb();\n\t\t\t--r._evalWait;\n\t\t\tr.run();\n\t\t\treturn res;\n\t\t},\n\t\tfv (v, bfv = false) {\t// Final value in possibly-reactive chain\n\t\t\twhile (v?.$reactive === reactive.type) v = v.rv;\n\t\t\treturn ((bfv && typeof v?._bundle === 'function') ? v._bundle() : v);\n\t\t},\n\t\trun () {\t\t\t\t\t\t// Run the eval queues (maybe)\n\t\t\tconst [ q0, q1, q2 ] = r._REQ;\n\t\t\tif (!r._evalWait && !r._runner && (q0.size || q1.size || q2.size)) r._runner = setTimeout(runner, 0);\n\t\t},\n\t\tget type () { return 1; },\t\t// Type 1: basic direct\n\t\ttypeOf (v) { return v?.$reactive; },// Reactive type, if any\n\t\tunbatch (cb) {\t\t\t\t\t// Combined untracked batch\n\t\t\t++r._evalWait;\n\t\t\t++r._untrack;\n\t\t\tconst res = cb();\n\t\t\t--r._untrack;\n\t\t\t--r._evalWait;\n\t\t\treturn res;\n\t\t},\n\t\tuntracked (cb) {\t\t\t\t// Execute callback untracked\n\t\t\t++r._untrack;\n\t\t\tconst res = cb();\n\t\t\t--r._untrack;\n\t\t\treturn res;\n\t\t},\n\t\t// Return a promise that resolves when the eval queues are empty\n\t\twait () {\n\t\t\tif (r._waiting) return r._waiting.promise;\n\t\t\tconst [ q0, q1, q2 ] = r._REQ;\n\t\t\tif (!r._evalWait && !q0.size && !q1.size && !q2.size) return Promise.resolve(false);\n\t\t\tr._waiting = Promise.withResolvers();\n\t\t\treturn r._waiting.promise;\n\t\t},\n\t\t/* PRIVATE METHODS */\n\t\t_queueEval (ro, dis = 0) {\t\t// Queue reactive evaluation\n\t\t\tdis = Math.min(dis, 2);\n\t\t\tif (typeof ro._sched === 'number') {\n\t\t\t\tif (ro._sched <= dis) return;\n\t\t\t\tr._REQ[ro._sched].delete(ro);\n\t\t\t}\n\t\t\tr._REQ[ro._sched = dis].add(ro);\n\t\t},\n\t});\n})(reactive);\nreactive.untr = reactive.untracked; // alias\n\nexport { reactive, reactive as default };\nexport const { batch, fv, run, typeOf, untracked, wait } = reactive;\n\n// END\n"],"names":["reactive","opts","r","Object","setPrototypeOf","_v","v","_cmp","compare","_rdy","_eager","eager","_pros","Set","_cons","_prototype","undefined","_defcmp","def","async","runner","_runner","_evalWait","q0","q1","q2","_REQ","getFirst","q","values","next","value","runFirst","rv","_err","lastYield","performance","now","cede","sliceTime","Promise","setTimeout","size","_waiting","resolve","_roPrototype","$reactive","type","readonly","this","getter","toString","valueOf","accessors","setter","_def","d","provider","_setNotify","_error","_schedule","e","error","_g","readonlyView","_rov","freeze","_sched","delete","_consumer","_untrack","consumer","_checkReady","_busy","ReferenceError","pc","res","then","console","TypeError","ripple","queueMicrotask","Error","message","cause","_s","vvf","_set","wv","c","add","p","cp","clear","dis","wasReady","nxt","con","set","setDef","setEager","unready","pro","a","b","_queueEval","run","chg","assign","_tasks","batch","cb","fv","bfv","_bundle","typeOf","unbatch","untracked","wait","promise","withResolvers","ro","Math","min","untr"],"mappings":"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"}