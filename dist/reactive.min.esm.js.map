{"version":3,"file":"reactive.min.esm.js","sources":["../src/reactive.esm.js"],"sourcesContent":["/*\n * reactive\n * A reactive value library supporting memoization and per-value\n * selection of lazy or eager, chain-less dependency evaluation.\n *\n * Copyright 2023-2025 by Kappa Computer Solutions, LLC and Brian Katzung\n * Author: Brian Katzung <briank@kappacs.com>\n */\n\n// Return a new reactive value object\nfunction reactive (opts = {}) {\n    const r = Object.setPrototypeOf({\n\t_v: opts.v,\t\t\t// Current value\n\t_cmp: opts.compare,\t\t// Comparison function/value\n\t_rdy: true,\t\t\t// Ready?\n\t_eager: opts.eager,\t\t// Eager function eval\n\t_pros: new Set(),\t\t// Providers\n\t_cons: new Set(),\t\t// Consumers\n\t// _busy: true/undefined,\t// Currently evaluating definition\n\t// _def: undefined,\t\t// Reactive definition/memo/effect\n\t// _g: undefined,\t\t// Getter function\n\t// _rov: undefined,\t\t// Read-only view\n\t// _sched: undefined,\t\t// Eval queue if scheduled\n\t// _s: undefined,\t\t// Setter function\n\n    }, reactive._prototype);\n\n    if (opts.compare === undefined) r._cmp = r._defcmp;\n    if (opts.def) r.def = opts.def;\n\n    return r;\n}\n\n(r => {\n    // Read-only-view prototype for reactive values\n    r._roPrototype = {\n\tget $reactive () { return r.type; },\n\tget readonly () { return true; },\n\tget rv () { return this.getter(); },\n\ttoString () { return this.getter().toString(); },\n\tvalueOf () { return this.getter(); },\n    };\n    // Full-access prototype for reactive values\n    r._prototype = Object.setPrototypeOf({\n\t/* PUBLIC ATTRIBUTES */\n\tget accessors () { return [this.getter, this.setter]; },\n\tget compare () { return this._cmp; },\n\tget def () { return this._def; },\n\tset def (d) {\t\t\t// Set/change/clear definition\n\t    if (d === undefined) {\t// Clear\n\t\tif (this._def) {\n\t\t    this.provider(null);\n\t\t    delete this._def;\n\t\t    this._setNotify(undefined);\n\t\t}\n\t    } else if (typeof d === 'function') {\n\t\t// Set/change\n\t\tthis.provider(null);\n\t\tthis._def = d;\n\t\tdelete this._error;\n\t\tthis._rdy = false;\n\t\tthis._schedule();\n\t    } else if (d?.$reactive === r.type) {\n\t\t// Clone a reactive value using its getter function\n\t\tthis.def = d.getter;\n\t    }\n\t},\n\tget eager () { return this._eager; },\n\tset eager (e) {\t\t\t// Change def eval eagerness\n\t    this._eager = e;\n\t    this._schedule();\n\t},\n\tget error () { return this._error; },\n\tget getter () {\t\t\t// Return getter function\n\t    return (this._g ||= () => this.rv);\n\t},\n\t// Return [getter, setter] pair\n\tget $reactive () { return r.type; },\n\tget readonly () { return false; },\n\tget readonlyView () {\t\t// Get read-only view\n\t    if (!this._rov) {\n\t\tthis._rov = Object.freeze(Object.setPrototypeOf({\n\t\t    get error () { return this._error; },\n\t\t    getter: this.getter,\n\t\t}, r._roPrototype));\n\t    }\n\t    return this._rov;\n\t},\n\tget rv () {\t\t\t// Current value (readable)\n\t    if (this._sched !== undefined) {\n\t\t// Remove from scheduled evaluation queue\n\t\tr._REQ[this._sched].delete(this);\n\t\tdelete this._sched;\n\t    }\n\t    if (r._consumer && !r._untrack) {\n\t\t// Producer-consumer tracking\n\t\tthis.consumer(r._consumer);\n\t\tr._consumer.provider(this);\n\t    }\n\t    if (!this._checkReady()) {\t// Recompute defined value?\n\t\t// Croak if trying to recursively reference our reactive\n\t\t// in order to define our value\n\t\tif (this._busy) throw new ReferenceError('Self-referential reactive definition');\n\t\t// Providers can change every iteration; start fresh\n\t\tthis.provider(null);\n\t\tconst pc = r._consumer;\t// Save previous consumer\n\t\tr._consumer = this;\t// We're the consumer now\n\t\tthis._busy = true;\t// For recursive def detection\n\t\t\t\t\t// Evaluate definition\n\t\ttry {\n\t\t    delete this._error;\n\t\t    const res = this._def(this._v);\n\t\t    delete this._busy;\n\t\t    r._consumer = pc;\t// Restore previous consumer\n\t\t    this._setNotify(res);\n\t\t} catch (e) {\t\t// Try to clean up, unwind on error\n\t\t    delete this._busy;\n\t\t    r._consumer = pc;\n\t\t    this._error = e;\n\t\t    this._rdy = true;\t// The error is our new result\n\t\t    this.ripple();\n\t\t    if (this._eager && !this._cons.size) {\n\t\t\t// In space, no one can hear you scream\n\t\t\tqueueMicrotask(() => { throw new Error(`[Reactive] ${e.message}`, { cause: [ e, this ] }); });\n\t\t    }\n\t\t    throw e;\n\t\t}\n\t    }\n\t    if (this._error) throw this._error;\n\t    return this._v;\n\t},\n\tget setter () {\t\t\t// Return setter function\n\t    return (this._s ||= vvf => this._set(vvf));\n\t},\n\tget wv () { return this.rv; },\t// Writable value\n\tset wv (v) {\n\t    // Setting a static value clears any existing definition.\n\t    // Unlike the setter function, a functional v is not special.\n\t    if (this._def) this.def = undefined;\n\t    this._setNotify(v);\n\t},\n\t/* PUBLIC METHODS */\n\tconsumer (c, add = true) {\t// Add/remove consumer\n\t    if (add) this._cons.add(c);\n\t    else this._cons.delete(c);\n\t},\n\tprovider (p, add = true) {\t// Add/remove/remove all provider(s)\n\t    if (p === null) {\n\t\t// Unsub from, and clear, all current providers\n\t\tfor (const cp of this._pros) cp.consumer(this, false);\n\t\tthis._pros.clear();\n\t    }\n\t    else if (add) this._pros.add(p);\n\t    else this._pros.delete(p);\n\t},\n\t// Ripple ready-state changes through consumers\n\tripple (dis = 0) {\n\t    // Distance 0: our value changed\n\t    // Distance 1: an adjacent value changed\n\t    // Distance >1: a more distant value changed; our recalc may or\n\t    //   may not be required depending on intermediate results\n\t    const wasReady = this._rdy;\n\t    if (dis === 1) this._rdy = false;\n\t    if (dis > 1 && this._rdy) this._rdy = undefined;\n\t    // Ripple if local or transitioning from ready\n\t    if (!dis || (wasReady && !this._rdy)) {\n\t\t++r._evalWait;\n\t\tconst nxt = dis + 1;\n\t\tfor (const con of this._cons) con.ripple(nxt);\n\t\t--r._evalWait;\n\t    }\n\t    this._schedule(dis);\t// Call me, maybe!\n\t},\n\tset (vvf) {\t\t\t// Chainable set\n\t    // e.g. .setEager(0).set(v0).setDef(v => f(v)).setEager(1)\n\t    // Accepts a value or a mapping function (like setter(vvf)).\n\t    this._set(vvf);\n\t    return this;\n\t},\n\t// Set value; ripple-notify consumers of changes\n\tsetDef (d) {\t\t\t// Set def (chainable)\n\t    this.def = d;\n\t    return this;\n\t},\n\tsetEager (e) {\t\t\t// Set eager (chainable)\n\t    this.eager = e;\n\t    return this;\n\t},\n\tunready () {\t\t\t// Force unready\n\t    if (this._def) this._rdy = false;\n\t    this._schedule();\n\t    return this;\n\t},\n\t/* PRIVATE METHODS */\n\t_checkReady () {\t\t// Determine boolean readiness\n\t    if (this._rdy !== undefined) return this._rdy;\n\t    /*\n\t     * When the readiness is undefined, check providers for ripple\n\t     * changes. If any provider has changed, we must recalculate too.\n\t     */\n\t    for (const pro of this._pros) {\n\t\t// Provider changes will be rippled to us (d=1)\n\t\tpro.rv;\n\t\tif (this._rdy === false) return false;\n\t    }\n\t    /*\n\t     * No providers rippled a change to us during (recursive)\n\t     * dependency checking, so we're actually still ready!\n\t     */\n\t    return (this._rdy = true);\n\t},\n\t_defcmp (a, b) { return a !== b; },// Default comparison function\n\t_schedule (dis = 0) {\t\t// Schedule for eval if needed\n\t    if (!this._rdy && this._sched === undefined && (this._eager || this._cons.size)) r._queueEval(this, dis);\n\t    r.run();\n\t},\n\t_set (vvf) {\t\t\t// Prototype setter\n\t    // Setting a static value clears any existing definition.\n\t    // Accepts a value or an old-to-new-value mapping function.\n\t    if (this._def) this.def = undefined;\n\t    if (typeof vvf === 'function') this._setNotify(vvf(this._v));\n\t    else this._setNotify(vvf);\n\t    return this._v;\n\t},\n\t_setNotify (v) {\n\t    const chg = (typeof this._cmp === 'function') ? this._cmp(this._v, v) : this._cmp;\n\t    this._v = v;\n\t    this._rdy = true;\n\t    delete this._error;\n\t    if (chg) this.ripple();\n\t},\n    }, r._roPrototype);\n\n    // Yielding recalculation queue runner\n    async function runner () {\n\tif (!r._evalWait) {\n\t    ++r._evalWait;\n\t    const [ q0, q1, q2 ] = r._REQ;\n\t    const runFirst = q => { try { q.values().next().value.rv; } catch (_err) {/**/} };\n\t    let lastYield = performance.now();\n\t    const cede = async () => {\n\t\tif (performance.now() - lastYield >= r.sliceTime) {\n\t\t    await new Promise(r => setTimeout(r, 0));\n\t\t    lastYield = performance.now();\n\t\t}\n\t    };\n\t    /*\n\t     * NB: .rv exceptions will be rethrown to consumers; we\n\t     * deliberately ignore them and process the rest of the graph.\n\t     * Abort if evalWait goes up (running a batch).\n\t     */\n\t    while (r._evalWait < 2) {\n\t\tfor (const ro of q0) {\n\t\t    if (r._evalWait < 2) try { ro.rv; } catch (_err) {/**/} finally { await cede(); }\n\t\t    else break;\n\t\t}\n\t\tif (r._evalWait > 1) break;\n\t\telse if (q1.size) runFirst(q1);\n\t\telse if (q2.size) runFirst(q2);\n\t\telse break;\t\t// All queues empty\n\t\tawait cede();\n\t    }\n\t    --r._evalWait;\n\t    if (r._waiting && !q0.size && !q1.size && !q2.size) {\n\t\t// Queues are now all empty; signal waiters\n\t\tconst resolve = r._waiting.resolve;\n\t\tr._waiting = undefined;\n\t\tresolve(true);\n\t    }\n\t}\n    }\n\n    Object.assign(r, {\n\t_evalWait: 0,\t\t\t// Suspend evaluation\n\tsliceTime: 5,\t\t\t// Slice yield threshold (ms)\n\t_tasks: [],\t\t\t// Run-queue tasks\n\t_untrack: 0,\t\t\t// Suspend tracking\n\t// Reactive evaluation queues\n\t_REQ: [ new Set(), new Set(), new Set() ],\n\t/* PUBLIC METHODS */\n\tbatch (cb) {\t\t\t// Execute callback as a batch\n\t    ++r._evalWait;\n\t    const res = cb();\n\t    --r._evalWait;\n\t    r.run();\n\t    return res;\n\t},\n\tfv (v, bfv = false) {\t// Final value in possibly-reactive chain\n\t    while (v?.$reactive === reactive.type) v = v.rv;\n\t    return ((bfv && typeof v?._bundle === 'function') ? v._bundle() : v);\n\t},\n\trun () {\t\t\t// Run the eval queues (maybe)\n\t    if (!r._evalWait) setTimeout(runner, 0);\n\t},\n\tget type () { return 1; },\t// Type 1: basic direct\n\ttypeOf (v) { return v?.$reactive; },// Reactive type, if any\n\tuntracked (cb) {\t\t// Execute callback untracked\n\t    ++r._untrack;\n\t    const res = cb();\n\t    --r._untrack;\n\t    return res;\n\t},\n\t// Return a promise that resolves when the eval queues are empty\n\twait () {\n\t    if (r._waiting) return r._waiting.promise;\n\t    const [ q0, q1, q2 ] = r._REQ;\n\t    if (!r._evalWait && !q0.size && !q1.size && !q2.size) return Promise.resolve(false);\n\t    r._waiting = Promise.withResolvers();\n\t    return r._waiting.promise;\n\t},\n\t/* PRIVATE METHODS */\n\t_queueEval (ro, dis = 0) {\t// Queue reactive evaluation\n\t    dis = Math.min(dis, 2);\n\t    if (typeof ro._sched === 'number') {\n\t\tif (ro._sched <= dis) return;\n\t\tr._REQ[ro._sched].delete(ro);\n\t    }\n\t    r._REQ[ro._sched = dis].add(ro);\n\t},\n    });\n})(reactive);\n\nexport { reactive, reactive as default };\nexport const { batch, fv, run, typeOf, untracked, wait } = reactive;\n\n// END\n"],"names":["reactive","opts","r","Object","setPrototypeOf","_v","v","_cmp","compare","_rdy","_eager","eager","_pros","Set","_cons","_prototype","undefined","_defcmp","def","async","runner","_evalWait","q0","q1","q2","_REQ","runFirst","q","values","next","value","rv","_err","lastYield","performance","now","cede","sliceTime","Promise","setTimeout","ro","size","_waiting","resolve","_roPrototype","$reactive","type","readonly","this","getter","toString","valueOf","accessors","setter","_def","d","provider","_setNotify","_error","_schedule","e","error","_g","readonlyView","_rov","freeze","_sched","delete","_consumer","_untrack","consumer","_checkReady","_busy","ReferenceError","pc","res","ripple","queueMicrotask","Error","message","cause","_s","vvf","_set","wv","c","add","p","cp","clear","dis","wasReady","nxt","con","set","setDef","setEager","unready","pro","a","b","_queueEval","run","chg","assign","_tasks","batch","cb","fv","bfv","_bundle","typeOf","untracked","wait","promise","withResolvers","Math","min"],"mappings":"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"}